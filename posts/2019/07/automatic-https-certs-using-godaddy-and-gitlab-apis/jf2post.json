{"author":{"name":"Yash Agarwal","type":"card","url":"https://yashagarwal.in/"},"content":{"html":"\u003cp\u003eBefore I start, here is some technical information about my website -\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHosted on Gitlab and usage its CD for automatic deployment, which is triggered on a git commit.\u003c/li\u003e\n\u003cli\u003eThe domain name registrar is GoDaddy.\u003c/li\u003e\n\u003cli\u003eLet\u0026rsquo;s Encrypt as the TLS certificate provider for my domain name.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLet\u0026rsquo;s Encrypt provides certificates for 90 days only, so I was forced to set up the \u003ccode\u003ecertbot\u003c/code\u003e every three months, then generate the certificate and \u003cem\u003emanually\u003c/em\u003e deploy the certificates to GitLab. It was frustrating because in three months, my shell probably will not remember the command I used last time, and I was too lazy to document the process somewhere.\u003c/p\u003e\n\u003cp\u003eThen I came across a \u003ca href=\"https://github.com/pallavagarwal07/NamesiloCert\"\u003eproject\u003c/a\u003e, which was trying to do a similar thing with other domain name registrar. I thought that this is an excellent setup to adapt and modify it to suit my needs. So I decided to write my module for automatic deployment of Let\u0026rsquo;s Encrypt certificates to GitLab.\u003c/p\u003e\n\u003ch2 id=\"how-does-lets-encrypt-work\"\u003eHow does Let\u0026rsquo;s Encrypt work?\u003c/h2\u003e\n\u003cp\u003eBefore Let\u0026rsquo;s Encrypt can generate the certificate for the domain, it requires the user to prove domain ownership. Let\u0026rsquo;s Encrypt provides two \u003ca href=\"https://letsencrypt.org/docs/challenge-types/\"\u003emethods\u003c/a\u003e to do this task -\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUpdating the DNS records of the domain registrar (DNS-01 challenge)\u003c/li\u003e\n\u003cli\u003eAdding an HTTP resource under a well-known URI on the website (HTTP-01 challenge)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUsing the second method requires me to add a file on my website, and I did not want to do that. Moreover, if in the future, I decide to host some other service, which does not have a website, then this method will fail.\u003c/p\u003e\n\u003cp\u003eThe first method requires that the domain configuration on the domain registrar is modified. GoDaddy provides a robust API, and it is not difficult to utilize that API to automate specific tasks. The probability of changing the registrar is quite low, at least for the next few years. It will be easier to generate the certificates for any subdomains, as all the subdomains will also be hosted under the same domain registrar.\u003c/p\u003e\n\u003ch2 id=\"how-does-the-tool-work\"\u003eHow does the tool work?\u003c/h2\u003e\n\u003cp\u003eSo here are the steps:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eCall \u003ccode\u003ecertbot\u003c/code\u003e with all the domain names\u003c/li\u003e\n\u003cli\u003eInvoke GoDaddy API to update the DNS records as indicated by Certbot\u003c/li\u003e\n\u003cli\u003eWait for 10 minutes for DNS changes to propagate\u003c/li\u003e\n\u003cli\u003eLet \u003ccode\u003ecertbot\u003c/code\u003e verify the DNS changes\u003c/li\u003e\n\u003cli\u003eUse the GitLab API to deploy the generated certificates to GitLab pages\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"step-1-invoking-certbot\"\u003eStep 1: Invoking certbot\u003c/h3\u003e\n\u003cp\u003eIn step 1, we call \u003ccode\u003ecertbot\u003c/code\u003e will the preferred method DNS. We also need to supply an email id (used by Let\u0026rsquo;s Encrypt to notify domain expiration). The \u003ccode\u003eEMAIL_ID\u003c/code\u003e environment variable can be used to store the email id of the user.\u003c/p\u003e\n\u003cp\u003eCertbot runs in an interactive mode by default. It is not desired in a scripted environment. Certbot also provides mechanisms to deploy the certificates to a local server automatically, but as we are hosting our website on Gitlab, we do not want the automatic deployment facility. So we need to invoke the \u003ccode\u003ecertbot\u003c/code\u003e command with \u003ccode\u003e--manual\u003c/code\u003e and \u003ccode\u003ecertonly\u003c/code\u003e modes.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003ecertbot   --manual \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e          --preferred-challenges dns \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e          --agree-tos \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e          --email \u003cspan class=\"s2\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"si\"\u003e${\u003c/span\u003e\u003cspan class=\"nv\"\u003eEMAIL_ID\u003c/span\u003e\u003cspan class=\"si\"\u003e}\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;\u003c/span\u003e \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e          --no-eff-email \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e          --expand \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e          --renew-by-default \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e          --manual-public-ip-logging-ok \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e          --noninteractive \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e          --redirect \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e          --config-dir \u003cspan class=\"si\"\u003e${\u003c/span\u003e\u003cspan class=\"nv\"\u003eDIR\u003c/span\u003e\u003cspan class=\"si\"\u003e}\u003c/span\u003e/generated/config \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e          --work-dir \u003cspan class=\"si\"\u003e${\u003c/span\u003e\u003cspan class=\"nv\"\u003eDIR\u003c/span\u003e\u003cspan class=\"si\"\u003e}\u003c/span\u003e/generated/work \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e          --logs-dir \u003cspan class=\"si\"\u003e${\u003c/span\u003e\u003cspan class=\"nv\"\u003eDIR\u003c/span\u003e\u003cspan class=\"si\"\u003e}\u003c/span\u003e/generated/logs \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e          --manual-auth-hook \u003cspan class=\"si\"\u003e${\u003c/span\u003e\u003cspan class=\"nv\"\u003eDIR\u003c/span\u003e\u003cspan class=\"si\"\u003e}\u003c/span\u003e/auth_hook.sh \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e          -d yashagarwal.in \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e          certonly\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe explanation for most of the flags used in the above command can be found by running the following command -\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003ecertbot --help\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe \u003ccode\u003e--manual-auth-hook\u003c/code\u003e flag is worth looking. This hook provides a mechanism to specify the executable, which can be used to facilitate domain ownership validation. In this case, the hook points to a script \u003ccode\u003eauth_hook.sh\u003c/code\u003e, which then calls a Go client, which interacts with GoDaddy API.\u003c/p\u003e\n\u003ch3 id=\"step-2-adding-dns-entry-to-godaddy-dns-manager\"\u003eStep 2: Adding DNS entry to GoDaddy DNS manager\u003c/h3\u003e\n\u003cp\u003eCertbot supplies two environment variables \u003ccode\u003eCERTBOT_DOMAIN\u003c/code\u003e, which contains the domain name to be verified and \u003ccode\u003eCERTBOT_VALIDATION\u003c/code\u003e, which includes a random string corresponding to \u003ccode\u003e_acme-challenge TXT\u003c/code\u003e entry. What this means is that, if I have\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003eCERTBOT_DOMAIN=yashagarwal.in\nCERTBOT_VALIDATION=6VNg5kDVI_BF1S9N5s74LTBHQnwDpQqKlblKRjIzBwM\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThen the DNS manager should contain a TXT entry \u003ccode\u003e_acme-challenge.yashagarwal.in\u003c/code\u003e with the value of \u003ccode\u003e6VNg5kDVI_BF1S9N5s74LTBHQnwDpQqKlblKRjIzBwM\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eauth_hook.sh\u003c/code\u003e file calls the Go client with the abovementioned environment variables. The relevant code can be found \u003ca href=\"https://github.com/yashhere/GoDaddy-GitLab-Certs/blob/master/auth_hook.sh\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eOnce all the DNS entries are added, the \u003ccode\u003eauth_hook.sh\u003c/code\u003e script will sleep for 10 minutes. It is to allow DNS changes to propagate throughout the Internet. It is a random duration as I could not find any GoDaddy support page mentioning the exact period used by them.\u003c/p\u003e\n\u003ch3 id=\"step-3-generation-of-certificates\"\u003eStep 3: Generation of certificates\u003c/h3\u003e\n\u003cp\u003eOnce the \u003ccode\u003eauth_hook.sh\u003c/code\u003e script returns successfully, \u003ccode\u003ecertbot\u003c/code\u003e will verify the DNS records. If the verification is successful, \u003ccode\u003ecertbot\u003c/code\u003e will generate the certificates in \u003ccode\u003e./generated/config/live/{CERTBOT_DOMAIN}\u003c/code\u003e directory.\u003c/p\u003e\n\u003ch3 id=\"step-4-deploying-the-certificates-to-gitlab\"\u003eStep 4: Deploying the certificates to GitLab\u003c/h3\u003e\n\u003cp\u003eI use the following command to deploy the certificates to Gitlab pages where my website is hosted -\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003ecurl  -vvv \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e      --request PUT \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e      --header \u003cspan class=\"s2\"\u003e\u0026#34;Private-Token:\u003c/span\u003e\u003cspan class=\"si\"\u003e${\u003c/span\u003e\u003cspan class=\"nv\"\u003eGITLAB_TOKEN\u003c/span\u003e\u003cspan class=\"si\"\u003e}\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;\u003c/span\u003e \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e      --form \u003cspan class=\"s2\"\u003e\u0026#34;certificate=@\u003c/span\u003e\u003cspan class=\"si\"\u003e${\u003c/span\u003e\u003cspan class=\"nv\"\u003ekey_dir\u003c/span\u003e\u003cspan class=\"si\"\u003e}\u003c/span\u003e\u003cspan class=\"s2\"\u003e/fullchain.pem\u0026#34;\u003c/span\u003e \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e      --form \u003cspan class=\"s2\"\u003e\u0026#34;key=@\u003c/span\u003e\u003cspan class=\"si\"\u003e${\u003c/span\u003e\u003cspan class=\"nv\"\u003ekey_dir\u003c/span\u003e\u003cspan class=\"si\"\u003e}\u003c/span\u003e\u003cspan class=\"s2\"\u003e/privkey.pem\u0026#34;\u003c/span\u003e \u003cspan class=\"se\"\u003e\\ \u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;https://gitlab.com/api/v4/projects/yashhere%2Fyashhere.gitlab.io/pages/domains/yashagarwal.in\u0026#34;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003ewhere\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"nv\"\u003ekey_dir\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;./generated/config/live/yashagarwal.in\u0026#34;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eMoreover, \u003ccode\u003eGITLAB_TOKEN\u003c/code\u003e is an environment variable that contains the API token generated from the Gitlab settings page.\u003c/p\u003e\n\u003ch2 id=\"automatic-deployment-using-travis-ci\"\u003eAutomatic Deployment using Travis CI\u003c/h2\u003e\n\u003cp\u003eIt is not automation if I have to run this script manually every three months. So I created a Travis CI job to automate this process. The job will run every month and deploy my certificates automatically. It has been four months, and I have not faced any issues with this setup.\u003c/p\u003e\n\u003cp\u003eThe code for this post can be viewed at \u003ca href=\"https://github.com/yashhere/GoDaddy-GitLab-Certs\"\u003eGithub\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThanks for reading. Cheers ðŸ˜„\u003c/p\u003e\n","text":"Before I start, here is some technical information about my website -\n Hosted on Gitlab and usage its CD for automatic deployment, which is triggered on a git commit. The domain name registrar is GoDaddy. Let\u0026rsquo;s Encrypt as the TLS certificate provider for my domain name.  Let\u0026rsquo;s Encrypt provides certificates for 90 days only, so I was forced to set up the certbot every three months, then generate the certificate and manually deploy the certificates to GitLab. It was frustrating because in three months, my shell probably will not remember the command I used last time, and I was too lazy to document the process somewhere.\nThen I came across a project, which was trying to do a similar thing with other domain name registrar. I thought that this is an excellent setup to adapt and modify it to suit my needs. So I decided to write my module for automatic deployment of Let\u0026rsquo;s Encrypt certificates to GitLab.\nHow does Let\u0026rsquo;s Encrypt work? Before Let\u0026rsquo;s Encrypt can generate the certificate for the domain, it requires the user to prove domain ownership. Let\u0026rsquo;s Encrypt provides two methods to do this task -\n Updating the DNS records of the domain registrar (DNS-01 challenge) Adding an HTTP resource under a well-known URI on the website (HTTP-01 challenge)  Using the second method requires me to add a file on my website, and I did not want to do that. Moreover, if in the future, I decide to host some other service, which does not have a website, then this method will fail.\nThe first method requires that the domain configuration on the domain registrar is modified. GoDaddy provides a robust API, and it is not difficult to utilize that API to automate specific tasks. The probability of changing the registrar is quite low, at least for the next few years. It will be easier to generate the certificates for any subdomains, as all the subdomains will also be hosted under the same domain registrar.\nHow does the tool work? So here are the steps:\n Call certbot with all the domain names Invoke GoDaddy API to update the DNS records as indicated by Certbot Wait for 10 minutes for DNS changes to propagate Let certbot verify the DNS changes Use the GitLab API to deploy the generated certificates to GitLab pages  Step 1: Invoking certbot In step 1, we call certbot will the preferred method DNS. We also need to supply an email id (used by Let\u0026rsquo;s Encrypt to notify domain expiration). The EMAIL_ID environment variable can be used to store the email id of the user.\nCertbot runs in an interactive mode by default. It is not desired in a scripted environment. Certbot also provides mechanisms to deploy the certificates to a local server automatically, but as we are hosting our website on Gitlab, we do not want the automatic deployment facility. So we need to invoke the certbot command with --manual and certonly modes.\ncertbot --manual \\  --preferred-challenges dns \\  --agree-tos \\  --email \u0026#34;${EMAIL_ID}\u0026#34; \\  --no-eff-email \\  --expand \\  --renew-by-default \\  --manual-public-ip-logging-ok \\  --noninteractive \\  --redirect \\  --config-dir ${DIR}/generated/config \\  --work-dir ${DIR}/generated/work \\  --logs-dir ${DIR}/generated/logs \\  --manual-auth-hook ${DIR}/auth_hook.sh \\  -d yashagarwal.in \\  certonly The explanation for most of the flags used in the above command can be found by running the following command -\ncertbot --help The --manual-auth-hook flag is worth looking. This hook provides a mechanism to specify the executable, which can be used to facilitate domain ownership validation. In this case, the hook points to a script auth_hook.sh, which then calls a Go client, which interacts with GoDaddy API.\nStep 2: Adding DNS entry to GoDaddy DNS manager Certbot supplies two environment variables CERTBOT_DOMAIN, which contains the domain name to be verified and CERTBOT_VALIDATION, which includes a random string corresponding to _acme-challenge TXT entry. What this means is that, if I have\nCERTBOT_DOMAIN=yashagarwal.in CERTBOT_VALIDATION=6VNg5kDVI_BF1S9N5s74LTBHQnwDpQqKlblKRjIzBwM Then the DNS manager should contain a TXT entry _acme-challenge.yashagarwal.in with the value of 6VNg5kDVI_BF1S9N5s74LTBHQnwDpQqKlblKRjIzBwM.\nThe auth_hook.sh file calls the Go client with the abovementioned environment variables. The relevant code can be found here.\nOnce all the DNS entries are added, the auth_hook.sh script will sleep for 10 minutes. It is to allow DNS changes to propagate throughout the Internet. It is a random duration as I could not find any GoDaddy support page mentioning the exact period used by them.\nStep 3: Generation of certificates Once the auth_hook.sh script returns successfully, certbot will verify the DNS records. If the verification is successful, certbot will generate the certificates in ./generated/config/live/{CERTBOT_DOMAIN} directory.\nStep 4: Deploying the certificates to GitLab I use the following command to deploy the certificates to Gitlab pages where my website is hosted -\ncurl -vvv \\  --request PUT \\  --header \u0026#34;Private-Token:${GITLAB_TOKEN}\u0026#34; \\  --form \u0026#34;certificate=@${key_dir}/fullchain.pem\u0026#34; \\  --form \u0026#34;key=@${key_dir}/privkey.pem\u0026#34; \\ \u0026#34;https://gitlab.com/api/v4/projects/yashhere%2Fyashhere.gitlab.io/pages/domains/yashagarwal.in\u0026#34; where\nkey_dir=\u0026#34;./generated/config/live/yashagarwal.in\u0026#34; Moreover, GITLAB_TOKEN is an environment variable that contains the API token generated from the Gitlab settings page.\nAutomatic Deployment using Travis CI It is not automation if I have to run this script manually every three months. So I created a Travis CI job to automate this process. The job will run every month and deploy my certificates automatically. It has been four months, and I have not faced any issues with this setup.\nThe code for this post can be viewed at Github.\nThanks for reading. Cheers ðŸ˜„\n"},"name":"Automatic HTTPS Certs Using GoDaddy and Gitlab APIs","published":"2019-07-23T16:40:28+05:30","summary":"Before I start, here is some technical information about my website -\n Hosted on Gitlab and usage its CD for automatic deployment, which is triggered on a git commit. The domain name registrar is GoDaddy. Let\u0026rsquo;s Encrypt as the TLS certificate provider for my domain name.  Let\u0026rsquo;s Encrypt provides certificates for 90 days only, so I was forced to set up the certbot every three months, then generate the certificate and manually deploy the certificates to GitLab.","type":"entry","url":"https://yashagarwal.in/posts/2019/07/automatic-https-certs-using-godaddy-and-gitlab-apis/"}